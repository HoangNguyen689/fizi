<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us dir=ltr><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Batch records creation with Go and Postgres-FIZI</title>
<meta name=theme-color><meta name=description content="Today I write a small note about creating multiple records in SQL database.
The stack include:

Postgres
Golang
Docker (Podman)

Setup
We will use the simple users table, with 2 main fields:

id (text): primary key
name (text)

Batch records creation in Postgres
We will start with the singular simplest SQL query.
INSERT INTO users VALUES ('1', 'User 1');
This query wil create a record in users table. What if we want to add many records.
The easiest way is to do what is succeeded again"><meta name=author content="FIZI"><link rel="preload stylesheet" as=style href=https://hoangnguyen689.github.io/fizi/main.min.css><link rel=preload as=image href=https://hoangnguyen689.github.io/fizi/theme.svg><link rel=preload as=image href=https://hoangnguyen689.github.io/fizi/twitter.svg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",()=>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1}))</script><link rel=icon href=https://hoangnguyen689.github.io/fizi/favicon.ico><link rel=apple-touch-icon href=https://hoangnguyen689.github.io/fizi/apple-touch-icon.png><meta name=generator content="Hugo 0.145.0"><meta itemprop=name content="Batch records creation with Go and Postgres"><meta itemprop=description content="Today I write a small note about creating multiple records in SQL database. The stack include:
Postgres Golang Docker (Podman) Setup We will use the simple users table, with 2 main fields:
id (text): primary key name (text) Batch records creation in Postgres We will start with the singular simplest SQL query.
INSERT INTO users VALUES ('1', 'User 1'); This query wil create a record in users table. What if we want to add many records. The easiest way is to do what is succeeded again"><meta itemprop=datePublished content="2025-04-01T10:52:10+09:00"><meta itemprop=dateModified content="2025-04-01T10:52:10+09:00"><meta itemprop=wordCount content="922"><meta itemprop=keywords content="Postgres,Golang,Pgx,Sqlc"><meta property="og:url" content="https://hoangnguyen689.github.io/fizi/posts/batch_records_creation_with_go_and_postgres/"><meta property="og:site_name" content="FIZI"><meta property="og:title" content="Batch records creation with Go and Postgres"><meta property="og:description" content="Today I write a small note about creating multiple records in SQL database. The stack include:
Postgres Golang Docker (Podman) Setup We will use the simple users table, with 2 main fields:
id (text): primary key name (text) Batch records creation in Postgres We will start with the singular simplest SQL query.
INSERT INTO users VALUES ('1', 'User 1'); This query wil create a record in users table. What if we want to add many records. The easiest way is to do what is succeeded again"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-01T10:52:10+09:00"><meta property="article:modified_time" content="2025-04-01T10:52:10+09:00"><meta property="article:tag" content="Postgres"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Pgx"><meta property="article:tag" content="Sqlc"><meta name=twitter:card content="summary"><meta name=twitter:title content="Batch records creation with Go and Postgres"><meta name=twitter:description content="Today I write a small note about creating multiple records in SQL database. The stack include:
Postgres Golang Docker (Podman) Setup We will use the simple users table, with 2 main fields:
id (text): primary key name (text) Batch records creation in Postgres We will start with the singular simplest SQL query.
INSERT INTO users VALUES ('1', 'User 1'); This query wil create a record in users table. What if we want to add many records. The easiest way is to do what is succeeded again"><link rel=canonical href=https://hoangnguyen689.github.io/fizi/posts/batch_records_creation_with_go_and_postgres/></head><body class="bg-(--bg) text-black antialiased duration-200 ease-out [-webkit-tap-highlight-color:transparent] dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-(--w) px-8 whitespace-nowrap lg:justify-center"><div class="relative z-50 flex items-center ltr:mr-auto rtl:ml-auto"><a class="-translate-y-[1px] text-2xl font-medium" href=https://hoangnguyen689.github.io/fizi/>FIZI</a><div class="btn-dark text-[0px] ltr:ml-4 rtl:mr-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden ltr:-mr-8 rtl:-ml-8" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full flex-col justify-center bg-(--bg) pb-16 duration-200 select-none lg:static lg:h-auto lg:flex-row lg:bg-transparent! lg:pb-0 lg:transition-none"><nav class="mt-12 flex justify-center space-x-10 lg:mt-0 lg:items-center ltr:lg:ml-14 rtl:space-x-reverse rtl:lg:mr-14 dark:invert"><a class="h-7 w-7 text-[0px] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/ndhoang96 target=_blank rel=me>twitter</a></nav></div></header><main class="prose prose-neutral dark:prose-invert relative mx-auto min-h-[calc(100vh-9rem)] max-w-(--w) px-8 pt-14 pb-16"><article><header class=mb-14><h1 class="my-0! pb-2.5">Batch records creation with Go and Postgres</h1><div class="text-xs antialiased opacity-60"><time>Apr 1, 2025</time></div></header><section><p>Today I write a small note about creating multiple records in SQL database.
The stack include:</p><ul><li>Postgres</li><li>Golang</li><li>Docker (Podman)</li></ul><h2 id=setup>Setup</h2><p>We will use the simple <code class="code-inline language-go"><span style=color:#1f2328>users</span></code> table, with 2 main fields:</p><ul><li>id (text): primary key</li><li>name (text)</li></ul><h2 id=batch-records-creation-in-postgres>Batch records creation in Postgres</h2><p>We will start with the singular simplest SQL query.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> users <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;1&#39;</span>, <span style=color:#e6db74>&#39;User 1&#39;</span>);
</span></span></code></pre></div><p>This query wil create a record in <code>users</code> table. What if we want to add many records.
The easiest way is to do what is succeeded again</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> users <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;3&#39;</span>, <span style=color:#e6db74>&#39;User 3&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> users <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;4&#39;</span>, <span style=color:#e6db74>&#39;User 4&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> users <span style=color:#66d9ef>VALUES</span> (<span style=color:#e6db74>&#39;5&#39;</span>, <span style=color:#e6db74>&#39;User 5&#39;</span>);
</span></span></code></pre></div><p>If we run these queries, the response time still fast. Because our <code>users</code> table is simple, has two fields, has no index, and we only insert three records.</p><p>Although the response time is small, we still can measure it. One of the way is using psql.
To make it easy to compare, we store the queries in file.</p><ul><li><code>singular_user.sql</code> for 1 query.</li><li><code>multiple_3_users.sql</code> for 3 queries.</li><li><code>multiple_1000_users.sql</code> for 1000 queries.</li><li>and so on &mldr;</li></ul><p>Let&rsquo;s go inside psql console and enable timing</p><pre tabindex=0><code class=language-psql data-lang=psql>db=# \timing
Timing is on.
</code></pre><p>And we can test the time each case</p><pre tabindex=0><code class=language-psql data-lang=psql>db=# \i singular_user.sql
INSERT 0 1
Time: 4.669 ms
</code></pre><pre tabindex=0><code class=language-psql data-lang=psql>db=# \i multiple_3_users.sql
INSERT 0 1
Time: 1.303 ms
INSERT 0 1
Time: 0.605 ms
INSERT 0 1
Time: 0.536 ms
</code></pre><p>As we can see, although we put multiple queries in one file, they are still processed in turn.
In each query, the database system does the sequence of actions.</p><p>&lt;TODO: Insert image></p><pre tabindex=0><code>SQL string
    ↓
[Parse]
    ↓
[Rewrite]
    ↓
[Plan]
    ↓
[Acquire locks]
    ↓
[Execute]
    ↓
[Return result]
</code></pre><p>Although the queries format seems similar, when receiving one query, all the above actions must be done.
Can we improve it by the similarity in the above queires.
Yes, we can. Using <code>Prapared statement</code> is the key. By preparing the format of the queries, we can by pass the <code>Plan</code> step, and excute it immediately.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>PREPARE</span> insert_user(varchar, varchar) <span style=color:#66d9ef>AS</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> users (id, name) <span style=color:#66d9ef>VALUES</span> (<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>EXECUTE</span> insert_user(<span style=color:#e6db74>&#39;3&#39;</span>, <span style=color:#e6db74>&#39;User 3&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>EXECUTE</span> insert_user(<span style=color:#e6db74>&#39;4&#39;</span>, <span style=color:#e6db74>&#39;User 4&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>EXECUTE</span> insert_user(<span style=color:#e6db74>&#39;5&#39;</span>, <span style=color:#e6db74>&#39;User 5&#39;</span>);
</span></span></code></pre></div><p>We can even do it better. <code>INSERT</code> provides a way to create multiple values in one query.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> users (id, name) <span style=color:#66d9ef>VALUES</span>
</span></span><span style=display:flex><span>    (<span style=color:#e6db74>&#39;3&#39;</span>, <span style=color:#e6db74>&#39;User 3&#39;</span>),
</span></span><span style=display:flex><span>    (<span style=color:#e6db74>&#39;4&#39;</span>, <span style=color:#e6db74>&#39;User 4&#39;</span>),
</span></span><span style=display:flex><span>    (<span style=color:#e6db74>&#39;5&#39;</span>, <span style=color:#e6db74>&#39;User 5&#39;</span>);
</span></span></code></pre></div><p>By using this way, we can save many &ldquo;duplicate step&rdquo; inside the database system, as well as round time trip between client and database system server.</p><p>Cool!</p><p>Are you curious that how many values can we insert in one query?
Of course, there is a limit. You can check it <a href="https://www.postgresql.org/docs/current/limits.html?utm_source=chatgpt.com">here</a></p><p>The field limit is 1GB. So technically, we can&rsquo;t insert more than 1GB of data in one query. But if we look further, the limitation is more strict.</p><p>The query is store in <strong>StringInfo</strong> , which <a href=https://github.com/postgres/postgres/blob/master/src/include/lib/stringinfo.h>currently limited to a length of 1GB</a>. Also, the <strong>MaxAllocSize</strong> is <a href=https://github.com/postgres/postgres/blob/3c6e8c123896584f1be1fe69aaf68dcb5eb094d5/src/include/utils/memutils.h#L40>1GB</a>. So, the actual data which can be inserted is smaller than the 1GB limitation.</p><p>However, 1GB of text query is big. We will reach the mitation of the resource (RAM, CPU, &mldr;etc) before we reach the 1GB limit. Want to try?</p><p>Let&rsquo;s create a docker machine that has 2GB memory and 6 vCPUs.
You can test with any size of data you want. But we will test with 500.000 records and 1.000.000 records.
With an empty users table, the 500.000 records is quite fast,but the 1.000.000 records is cracked.
When seeing the postgres log, just the signal kill is displayed. It usually mean we get Out of Memory (OOM).
We cab see memory usage by <code>docker stats</code> command. And we can see the raise of memory in instant.</p><p>Let raise the memory of docker instant to 8GB and try again. Now, we can insert 1.000.000 records in one query quite fast.</p><p>But it seems that the memory dependency is not good. Any other ways to achieve large batch insertions?</p><p>There are 2 ways.</p><ul><li>Use COPY command</li><li>Use 3rd tool: pg_bulkload</li></ul><p>The COPY command is a fast way to put a large data set into a table.</p><p>Why is COPY fast?</p><p>It pass the data directly into the table.</p><p>How about pg_bulkload?</p><p>It even faster than COPY command in case of large data set.</p><p>It process directly with the table heap file, has option to by pass WAL, no trigger, no constraints, no index when loading.</p><p>Here is the benchmark of inserting 1.000.000 user records.</p><table><thead><tr><th>Method</th><th>Command</th><th>Time</th></tr></thead><tbody><tr><td>INSERT</td><td>time podman exec -i postgres_instance psql -U postgres -d db &lt; _out/batch_create_1000000_users.sql</td><td>0.04s user 0.05s system 1% cpu 7.065 total</td></tr><tr><td>COPY</td><td>time podman exec -i postgres_instance psql -U postgres -d db -c &ldquo;\COPY users(id, name) FROM &lsquo;/tmp/batch_create_1000000_users.csv&rsquo; CSV&rdquo;</td><td>0.03s user 0.02s system 2% cpu 2.148 total</td></tr><tr><td>pg_bulkload WAL on</td><td>time podman exec -i postgres_instance pg_bulkload -d db -U postgres /tmp/bulkload_on.ctl</td><td>0.03s user 0.02s system 2% cpu 2.089 total</td></tr><tr><td>pg_bulkload WAL off</td><td>time podman exec -it postgres_instance pg_bulkload -d db -U postgres /tmp/bulkload_off.ctl</td><td>0.03s user 0.02s system 2% cpu 1.776 total</td></tr><tr><td>pg_bulkload parralel</td><td>time podman exec -it postgres_instance pg_bulkload -d db -U postgres /tmp/bulkload_parralel.ctl</td><td>0.02s user 0.01s system 1% cpu 1.552 total</td></tr></tbody></table><p>As the above result, we can see the INSERT multiple values is slowest, took 7.065 seconds.
The COPY command is faster, took 2.148 seconds.
The pg_bulkload is the fastest, took 1.552 seconds.</p><h2 id=golang-implementation>Golang implementation</h2><p>There&rsquo;re 2 libs that deal with Postgres in Golang.</p><ul><li>pg</li><li>pgx</li></ul><p>The pgx is popular now and strongly supported.</p><p>To deal with SQL, there&rsquo;re many ways.</p><p>To be continued!</p></section><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://hoangnguyen689.github.io/fizi/tags/postgres>postgres</a><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://hoangnguyen689.github.io/fizi/tags/golang>golang</a><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://hoangnguyen689.github.io/fizi/tags/pgx>pgx</a><a class="mb-1.5 rounded-lg bg-black/[3%] px-5 py-1 no-underline hover:bg-black/[6%] ltr:mr-1.5 rtl:ml-1.5 dark:bg-white/[8%] dark:hover:bg-white/[12%]" href=https://hoangnguyen689.github.io/fizi/tags/sqlc>sqlc</a></footer></article></main><footer class="mx-auto flex h-[4.5rem] max-w-(--w) items-center px-8 text-xs tracking-wider uppercase opacity-60"><div class=mr-auto>&copy;2025<a class=link href=https://hoangnguyen689.github.io/fizi/>FIZI</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>powered by hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>hugo-paper</a></footer></body></html>